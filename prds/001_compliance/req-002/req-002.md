# **Technical Implementation Details: REQ-002**

## **Requirement: Make Controllers "Skinny"**

> **User Story:** As a developer, I want controllers to be "skinny" by moving all business logic into Action or Service classes within the Domain Layer.

---

### **Objective**

To refactor controllers so that their sole responsibility is handling HTTP-layer concerns. All business logic will be extracted and encapsulated within single-purpose, invokable "Action" classes located in the appropriate domain within the `src/` directory.

### **Implementation Steps**

This process will be demonstrated using a hypothetical example, as the current project has no complex controllers. The principle should be applied to all future and existing controllers that contain business logic.

**Scenario:** Assume we have a `OrderController` with a `store` method containing business logic.

```php
// BEFORE: A "fat" controller method
public function store(Request $request)
{
    $request->validate([
        'product_id' => 'required|exists:products,id',
        'quantity' => 'required|integer|min:1',
    ]);

    // Business logic starts here
    $product = Product::find($request->product_id);
    if ($product->stock < $request->quantity) {
        throw new \Exception('Not enough stock.');
    }

    $order = Order::create([
        'user_id' => auth()->id(),
        'total_price' => $product->price * $request->quantity,
    ]);

    $product->decrement('stock', $request->quantity);
    // Business logic ends here

    return redirect()->route('orders.show', $order);
}
```

---

1.  **Identify or Create the Domain:**
    *   For the `OrderController`, the corresponding domain is `Orders`.
    *   Create the directory structure: `src/Orders/Actions`.

2.  **Create the Data Transfer Object (DTO):**
    *   Use `spatie/laravel-data` (to be installed in REQ-009) to create a DTO for handling the incoming data.
    *   **File:** `src/Orders/Data/CreateOrderData.php`
    ```php
    <?php

    namespace Domain\Orders\Data;

    use Spatie\LaravelData\Data;

    class CreateOrderData extends Data
    {
        public function __construct(
            public readonly int $product_id,
            public readonly int $quantity,
            public readonly int $user_id,
        ) {}
    }
    ```

3.  **Create the Action Class:**
    *   Create a new, single-purpose, invokable class that will contain the extracted business logic.
    *   **File:** `src/Orders/Actions/CreateOrderAction.php`
    ```php
    <?php

    namespace Domain\Orders\Actions;

    use Domain\Orders\Data\CreateOrderData;
    use Domain\Orders\Models\Order;
    use Domain\Products\Models\Product;
    use Illuminate\Support\Facades\DB;

    class CreateOrderAction
    {
        public function __invoke(CreateOrderData $data): Order
        {
            return DB::transaction(function () use ($data) {
                $product = Product::findOrFail($data->product_id);

                if ($product->stock < $data->quantity) {
                    throw new \Exception('Not enough stock.');
                }

                $order = Order::create([
                    'user_id' => $data->user_id,
                    'total_price' => $product->price * $data->quantity,
                ]);

                $product->decrement('stock', $data->quantity);

                return $order;
            });
        }
    }
    ```

4.  **Refactor the Controller:**
    *   Modify the controller to be "skinny." It should now delegate all work to the Action class.
    *   It uses a Form Request (see REQ-003) for validation and the Action for business logic.
    *   **File:** `app/Http/Controllers/OrderController.php`
    ```php
    <?php

    namespace App\Http\Controllers;

    use App\Http\Requests\StoreOrderRequest; // See REQ-003
    use Domain\Orders\Actions\CreateOrderAction;
    use Domain\Orders\Data\CreateOrderData;

    class OrderController extends Controller
    {
        public function store(StoreOrderRequest $request, CreateOrderAction $createOrder)
        {
            $orderData = CreateOrderData::from([
                ...$request->validated(),
                'user_id' => auth()->id(),
            ]);

            $order = $createOrder($orderData);

            return redirect()->route('orders.show', $order)
                ->with('success', 'Order created successfully.');
        }
    }
    ```

### **Verification**

1.  The controller method is significantly smaller and contains no direct business logic (no database queries, no calculations, no state changes).
2.  The controller's only responsibilities are:
    *   Receiving the `Request`.
    *   Delegating validation to a Form Request.
    *   Preparing data and calling the Action class.
    *   Returning an HTTP response.
3.  The business logic is fully contained within the `CreateOrderAction` class and is testable in isolation.

### **Risks and Mitigation**

*   **Risk:** Logic might be incorrectly transferred, or dependencies might be missed.
    *   **Mitigation:** Write a unit test for the Action class (`CreateOrderActionTest`) to verify its behavior independently of the controller. Write a feature test for the controller endpoint to ensure the entire flow works as expected after the refactor.
